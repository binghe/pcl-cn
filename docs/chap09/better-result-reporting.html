<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.relation" scheme="URI" content="../chap09/building-a-unit-test-framework.html"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="better-result-reporting更好的结果输出"><link rel="stylesheet" type="text/css" href="../commonltr.css"><title>Better Result Reporting（更好的结果输出）</title></head><body id="better-result-reporting更好的结果输出"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">Better Result Reporting（更好的结果输出）</h1><div class="body"><p class="p">As long as you have only one test function, the current result
reporting is pretty clear. If a particular test case fails, all you
have to do is find the test case in the check form and figure out why
it's failing. But if you write a lot of tests, you'll probably want to
organize them somehow, rather than shoving them all into one
function. For instance, suppose you wanted to add some test cases for
the <code class="ph codeph">*</code> function. You might write a new test function.</p><p class="p">由于只有一个测试函数，所以当前的结果输出是相当清晰的。如果一个特定的测试用例失败了，那么只需在
<code class="ph codeph">check</code> 形式中找到那个测试用例并找出其失败原因即可。但如果编写了大量测试，会可能就要以某种方式将它们组织起来，而不是将它们全部塞进一个函数里。例如，假设想要对
<code class="ph codeph">*</code> 函数添加一些测试用例，则可以写一个新的测试函数。</p><pre class="pre codeblock lisp"><code>(defun test-* ()
  (check
    (= (* 2 2) 4)
    (= (* 3 5) 15)))</code></pre><p class="p">Now that you have two test functions, you'll probably want another
function that runs all the tests. That's easy enough.</p><p class="p">现在有了两个测试函数，你可能还想用另一个函数来运行所有测试，这也相当简单。</p><pre class="pre codeblock lisp"><code>(defun test-arithmetic ()
  (combine-results
   (test-+)
   (test-*)))</code></pre><p class="p">In this function you use combine-results instead of check since both
<code class="ph codeph">test-+</code> and <code class="ph codeph">test-*</code> will take care of reporting their own results. When
you run <code class="ph codeph">test-arithmetic</code>, you'll get the following results:</p><p class="p">这个函数使用 <code class="ph codeph">combine-results</code> 来代替 <code class="ph codeph">check</code>，因为 <code class="ph codeph">test-+</code>
和 <code class="ph codeph">test-*</code> 都将分别汇报它们自己的结果。运行 <code class="ph codeph">test-arithmetic</code> 将得到下列结果：</p><pre class="pre codeblock lisp"><code>CL-USER&gt; (test-arithmetic)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
pass ... (= (* 2 2) 4)
pass ... (= (* 3 5) 15)
T</code></pre><p class="p">Now imagine that one of the test cases failed and you need to track
down the problem. With only five test cases and two test functions, it
won't be too hard to find the code of the failing test case. But
suppose you had 500 test cases spread across 20 functions. It might be
nice if the results told you what function each test case came from.</p><p class="p">现在假设其中一个测试用例失败了并且需要跟踪该问题。在只有五个测试用例和两个测试函数的情况下，找出失败测试用例的代码并不太困难。但假如有
500 个测试用例分散在 20
个函数里，如果测试结果可以显示每个测试用例来自什么函数就非常好了。</p><p class="p">Since the code that prints the results is centralized in
report-result, you need a way to pass information about what test
function you're in to <code class="ph codeph">report-result</code>. You could add a parameter to
<code class="ph codeph">report-result</code> to pass this information, but check, which generates the
calls to <code class="ph codeph">report-result</code>, doesn't know what function it's being called
from, which means you'd also have to change the way you call check,
passing it an argument that it simply passes onto <code class="ph codeph">report-result</code>.</p><p class="p">由于打印结果的代码集中在 <code class="ph codeph">report-result</code>
函数里，所以需用一种方式来当前所在测试函数的信息传递给 <code class="ph codeph">report-result</code>。可以为
<code class="ph codeph">report-result</code> 添加一个形参来传递这一信息，但生成 <code class="ph codeph">report-result</code>
调用的 <code class="ph codeph">check</code> 却并不知道它是从什么函数被调用的，这就意味着还需要改变调用
<code class="ph codeph">check</code> 的方式，向其传递一个参数使其随后传给 <code class="ph codeph">report-result</code>。</p><p class="p">This is exactly the kind of problem dynamic variables were designed to
solve. If you create a dynamic variable that each test function binds
to the name of the function before calling check, then report-result
can use it without check having to know anything about it.</p><p class="p">设计动态变量就是用于解决这类问题的。如果创建一个动态变量使得每个测试函数在调用
<code class="ph codeph">check</code> 之前将其函数名绑定于其上，那么 <code class="ph codeph">report-result</code>
就可以无需理会 <code class="ph codeph">check</code> 来使用它了。</p><p class="p">Step one is to declare the variable at the top level.</p><p class="p">第一步是在最上层声明这个变量。</p><pre class="pre codeblock lisp"><code>(defvar *test-name* nil)</code></pre><p class="p">Now you need to make another tiny change to <code class="ph codeph">report-result</code> to include
<code class="ph codeph">*test-name*</code> in the <strong class="ph b">FORMAT</strong> output.</p><p class="p">现在你需要对 <code class="ph codeph">report-result</code> 稍微改动一下，使其在FORMAT输出中包括 <code class="ph codeph">*test-name*</code>。</p><pre class="pre codeblock lisp"><code>(format t "~:[FAIL~;pass~] ... ~a: ~a~%" result *test-name* form)</code></pre><p class="p">With those changes, the test functions will still work but will
produce the following output because <code class="ph codeph">*test-name*</code> is never rebound:</p><p class="p">有了这些改变，测试函数将仍然可以工作但将产生下面的输出，因为
<code class="ph codeph">*test-name*</code> 从未被重新绑定：</p><pre class="pre codeblock lisp"><code>CL-USER&gt; (test-arithmetic)
pass ... NIL: (= (+ 1 2) 3)
pass ... NIL: (= (+ 1 2 3) 6)
pass ... NIL: (= (+ -1 -3) -4)
pass ... NIL: (= (* 2 2) 4)
pass ... NIL: (= (* 3 5) 15)
T</code></pre><p class="p">For the name to be reported properly, you need to change the two test functions.</p><p class="p">为了正确报告测试名称，需要改变两个测试函数。</p><pre class="pre codeblock lisp"><code>(defun test-+ ()
  (let ((*test-name* 'test-+))
    (check
      (= (+ 1 2) 3)
      (= (+ 1 2 3) 6)
      (= (+ -1 -3) -4))))

(defun test-* ()
  (let ((*test-name* 'test-*))
    (check
      (= (* 2 2) 4)
      (= (* 3 5) 15))))</code></pre><p class="p">Now the results are properly labeled.</p><p class="p">现在结果被正确地标记了。</p><pre class="pre codeblock lisp"><code>CL-USER&gt; (test-arithmetic)
pass ... TEST-+: (= (+ 1 2) 3)
pass ... TEST-+: (= (+ 1 2 3) 6)
pass ... TEST-+: (= (+ -1 -3) -4)
pass ... TEST-*: (= (* 2 2) 4)
pass ... TEST-*: (= (* 3 5) 15)
T</code></pre></div><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../chap09/building-a-unit-test-framework.html">Practical: Building a Unit Test Framework（实践：构建一个单元测试框架）</a></div></div></nav></article></main></body></html>