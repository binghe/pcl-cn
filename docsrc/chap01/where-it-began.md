# Where It Began（Lisp 的诞生）

Common Lisp is the modern descendant of the Lisp language first
conceived by John McCarthy in 1956. Lisp circa 1956 was designed for
"symbolic data processing"7 and derived its name from one of the
things it was quite good at: LISt Processing. We've come a long way
since then: Common Lisp sports as fine an array of modern data types
as you can ask for: a condition system that, as you'll see in Chapter
19, provides a whole level of flexibility missing from the exception
systems of languages such as Java, Python, and C++; powerful
facilities for doing object-oriented programming; and several language
facilities that just don't exist in other programming languages. How
is this possible? What on Earth would provoke the evolution of such a
well-equipped language?

Common Lisp 是 1956 年 John McCarthy 发明的 Lisp 语言的现代版本。Lisp
在 1956 年被设计用于 “符号数据处理”，而 Lisp
这个名字本身就来源于其最擅长的工作：列表处理（LISt Processing）。从那时起，Lisp
得到了长足的发展：Common Lisp
引人瞩目地具备一系列现代数据类型；将在第 19 章里介绍的状态系统提供了
Java、Python 和 C++
等语言的异常系统里所没有的充分灵活性；强大的面向对象编程支持，以及其他编程语言里完全不存在的一些语言机制。这一切怎么可能呢？怎么会进化出如此装备精良的语言来呢？

Well, McCarthy was (and still is) an artificial intelligence (AI)
researcher, and many of the features he built into his initial version
of the language made it an excellent language for AI
programming. During the AI boom of the 1980s, Lisp remained a favorite
tool for programmers writing software to solve hard problems such as
automated theorem proving, planning and scheduling, and computer
vision. These were problems that required a lot of hard-to-write
software; to make a dent in them, AI programmers needed a powerful
language, and they grew Lisp into the language they needed. And the
Cold War helped--as the Pentagon poured money into the Defense
Advanced Research Projects Agency (DARPA), a lot of it went to folks
working on problems such as large-scale battlefield simulations,
automated planning, and natural language interfaces. These folks also
used Lisp and continued pushing it to do what they needed.

原来，McCarthy 曾经是（现在也是）一名人工智能（AI）研究者，他在 Lisp
语言的最初版本里内置的很多特性使其成为了 AI 编程的绝佳语言。在 AI
繁荣昌盛的 20 世纪 80 年代，Lisp
始终是程序员们所偏爱的工具，广泛用于编写软件来求解包括自动定理证明、规划和调度以及计算机视觉在内的各种困难问题。这些问题都需要大量难于编写的软件，为此，AI
程序员们需要一门强大的语言，而他们就将 Lisp
发展成了这样一门语言。另外，冷战也起了积极的作用——五角大楼向国防部高级研究规划局（DARPA）投入了大量资金，其中的相当一部分用于研究诸如大规模战场模拟、自动规划以及自然语言接口等问题。这些研究人员也在使用
Lisp 并且持续地对其进行改进以满足自身需要。

The same forces that drove Lisp's feature evolution also pushed the
envelope along other dimensions--big AI problems eat up a lot of
computing resources however you code them, and if you run Moore's law
in reverse for 20 years, you can imagine how scarce computing
resources were on circa-80s hardware. The Lisp guys had to find all
kinds of ways to squeeze performance out of their
implementations. Modern Common Lisp implementations are the heirs to
those early efforts and often include quite sophisticated, native
machine code-generating compilers. While today, thanks to Moore's law,
it's possible to get usable performance from a purely interpreted
language, that's no longer an issue for Common Lisp. As I'll show in
Chapter 32, with proper (optional) declarations, a good Lisp compiler
can generate machine code quite similar to what might be generated by
a C compiler.

推动 Lisp 特性进化的动力也同样推动了其他相关领域的发展——大型的 AI
问题无论如何编码总是要耗费大量的计算资源，而如果按照摩尔定律倒推 20
年，你就可以想象 80 年代的计算资源是何等的贫乏了。Lisp
工作者们不得不想尽办法从实现中获得更多的性能。现代 Common Lisp
实现就是这些早期工作的结晶，它们通常都带有相当专业的可产生原生机器码的编译器。感谢摩尔定律，今天我们从任何纯解释型语言里也能获得可接受的性能了，性能对于
Common Lisp 来说再也不是问题了。不过，你在第 32
章可以看到，通过使用适当的（可选）变量声明，一个好的
Lisp 编译器所生成的机器码，完全可以跟 C 编译器所生成的机器码相媲美。

The 1980s were also the era of the Lisp Machines, with several
companies, most famously Symbolics, producing computers that ran Lisp
natively from the chips up. Thus, Lisp became a systems programming
language, used for writing the operating system, editors, compilers,
and pretty much everything else that ran on the Lisp Machines.

20 世纪 80 年代也是 Lisp 机的年代，当时好几家公司（其中最著名的是
Symbolics）都在生产可以在芯片上直接运行 Lisp
的计算机系统。Lisp 因此成了系统级编程语言，被广泛用于编写操作系统、编辑器、编译器，以及
Lisp 机上的大量其他软件。

In fact, by the early 1980s, with various AI labs and the Lisp machine
vendors all providing their own Lisp implementations, there was such a
proliferation of Lisp systems and dialects that the folks at DARPA
began to express concern about the Lisp community splintering. To
address this concern, a grassroots group of Lisp hackers got together
in 1981 and began the process of standardizing a new language called
Common Lisp that combined the best features from the existing Lisp
dialects. Their work was documented in the book Common Lisp the
Language by Guy Steele (Digital Press, 1984)--CLtL to the
Lisp-cognoscenti.

事实上，到了 20 世纪 80 年代早期，几家 AI 实验室和 Lisp 机厂商都提供了他们自己的
Lisp 实现，众多的 Lisp 系统和方言让 DARPA 开始担心 Lisp
社区可能走向分裂。为了应对这些担忧，一个由 Lisp
黑客组成的草根组织于 1981 年成立，旨在结合既有 Lisp 方言之所长，定义一种新的称为
Common Lisp 的标准化 Lisp 语言。最后，他们的工作成果记录在了 Guy
Steele 的 Common Lisp: the Language（CLtL，Digital Press，1984
年）一书里。这本书相当于 Lisp 的圣经。

By 1986 the first Common Lisp implementations were available, and the
writing was on the wall for the dialects it was intended to
replace. In 1996, the American National Standards Institute (ANSI)
released a standard for Common Lisp that built on and extended the
language specified in CLtL, adding some major new features such as the
CLOS and the condition system. And even that wasn't the last word:
like CLtL before it, the ANSI standard intentionally leaves room for
implementers to experiment with the best way to do things: a full Lisp
implementation provides a rich runtime environment with access to GUI
widgets, multiple threads of control, TCP/IP sockets, and more. These
days Common Lisp is evolving much like other open-source
languages--the folks who use it write the libraries they need and
often make them available to others. In the last few years, in
particular, there has been a spurt of activity in open-source Lisp
libraries.

到 1986 年的时候，首批 Common Lisp 实现诞生了，它们是在 Common Lisp
试图取代的那些方言的基础上写成的。1996 年，美国国家标准化组织（ANSI）发布了一个建立在
CLtL 之上并加以扩展的 Common Lisp 标准，其中增加了一些主要的新特性，包括
CLOS 和状态系统。但事情还没结束：跟此前的 CLtL 一样，ANSI
标准有意为语言实现者保留了一定空间以试验各种最佳的工作方式。一个完整的
Lisp 实现将带有丰富的运行时环境，并提供 GUI 接口、多线程控制和 TCP/IP
协议支持等。今天的 Common Lisp 则进化得更像其他的开源语言——用户可以编写他们所需要的库并开放给其他人使用。在过去的几年里，开源
Lisp 库领域尤为活跃。

So, on one hand, Lisp is one of computer science's "classical"
languages, based on ideas that have stood the test of time.8 On the
other, it's a thoroughly modern, general-purpose language whose design
reflects a deeply pragmatic approach to solving real problems as
efficiently and robustly as possible. The only downside of Lisp's
"classical" heritage is that lots of folks are still walking around
with ideas about Lisp based on some particular flavor of Lisp they
were exposed to at some particular time in the nearly half century
since McCarthy invented Lisp. If someone tells you Lisp is only
interpreted, that it's slow, or that you have to use recursion for
everything, ask them what dialect of Lisp they're talking about and
whether people were wearing bell-bottoms when they learned it.

所以，一方面，Lisp 是计算机科学领域的“经典语言”之一，构建在经过时间考验的各种思想之上。 另一方面，它完全是一门现代的通用语言，其设计反映了尽可能高效和可靠地求解实际问题的实用主义观点。Lisp
“经典”遗产的唯一缺点是许多人仍然生活在片面的
Lisp 背景之下——他们可能只是在 McCarthy 发明 Lisp
以来的近半个世纪中的某些特定时刻接触到了这门语言的某些方面。如果有人告诉你
Lisp 只能被解释执行，因此会很慢，或者你不得不用递归来干每件事，那么一定要问问他们究竟在谈论哪种
Lisp 方言，以及他们是否是在计算机远古时代学到这些东西的。
